<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Mudae $oc Assistant</title>

  <style>
    :root {
      --bg: #313338;
      --panel: #2b2d31;
      --cell: #4e5058;
      --text: #dbdee1;
      --danger: #ed4245;

      --possible: #5865f2;
      --blocked: #232428;
      --blockedText: #8a8f98;
    }

    body {
      font-family: "gg sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h2 {
      margin: 6px 0 2px 0;
      line-height: 1.1;
    }

    .subtitle {
      margin: 0 0 14px 0;
      font-size: 0.72rem;
      opacity: 0.75;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(5, 60px);
      gap: 8px;
      background: var(--panel);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 18px;
    }

    .cellBox {
      width: 60px;
      height: 45px;
      background: var(--cell);
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      user-select: none;
      overflow: hidden;
    }

    .cellBox:hover { opacity: 0.86; }

    .cellBox.possible {
      background: var(--possible);
      color: #fff;
    }

    .cellBox.blocked {
      background: var(--blocked);
      color: var(--blockedText);
    }

    .cellBox.locked {
      cursor: not-allowed;
    }

    .icon {
      width: 22px;
      height: 22px;
      pointer-events: none;
    }

    .prob {
      margin-top: 2px;
      font-size: 0.78rem;
      font-weight: 900;
      pointer-events: none;
      line-height: 1;
    }

    /* Palette: 2 rows of 5 */
    .palette {
      display: grid;
      grid-template-columns: repeat(5, 56px);
      gap: 10px;
      background: var(--panel);
      padding: 14px;
      border-radius: 8px;
      justify-content: center;
      align-items: center;
    }

    .inkBtn {
      width: 56px;
      height: 44px;
      border-radius: 10px;
      cursor: pointer;
      border: 2px solid transparent;
      background: rgba(255,255,255,0.06);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .inkBtn:hover { opacity: 0.9; }

    .inkBtn.active {
      border-color: #fff;
      box-shadow: 0 0 10px rgba(255,255,255,0.25);
    }

    .inkBtn img {
      width: 26px;
      height: 26px;
      pointer-events: none;
    }

    .controls { margin-top: 16px; }

    .resetBtn {
      background: var(--danger);
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 900;
    }
  </style>
</head>

<body>
  <h2>Mudae $oc Assistant</h2>
  <p class="subtitle">Each % is the chance Red is in that square (given your clues)</p>

  <div class="grid" id="grid"></div>
  <div class="palette" id="palette"></div>

  <div class="controls">
    <button class="resetBtn" id="clearBtn">Clear Board</button>
  </div>

  <script>
    /* ----------------------------- icons ----------------------------- */
    const ICONS = {
      Purple:  "https://cdn.discordapp.com/emojis/1437140625844867244.webp",
      Blue:    "https://cdn.discordapp.com/emojis/1437140639987929108.webp",
      Teal:    "https://cdn.discordapp.com/emojis/1437140651614535680.webp",
      Yellow:  "https://cdn.discordapp.com/emojis/1437140677187338310.webp",
      Orange:  "https://cdn.discordapp.com/emojis/1437140688608432185.webp",
      Green:   "https://cdn.discordapp.com/emojis/1437140664193126441.webp",
      Red:     "https://cdn.discordapp.com/emojis/1437140700604137554.webp",
      White:   "https://cdn.discordapp.com/emojis/1437140737459486780.webp",
      Black:   "https://cdn.discordapp.com/emojis/1437140725492879471.webp",
      Mystery: "https://cdn.discordapp.com/emojis/1437140748423270441.webp",
    };

    // Two rows of 5. Mystery acts as eraser/clear.
    const INKS = [
      { key: "None",   icon: ICONS.Mystery, title: "Mystery (clear cell)" },
      { key: "Teal",   icon: ICONS.Teal,    title: "Teal" },
      { key: "Blue",   icon: ICONS.Blue,    title: "Blue" },
      { key: "Yellow", icon: ICONS.Yellow,  title: "Yellow" },
      { key: "Green",  icon: ICONS.Green,   title: "Green" },

      { key: "Orange", icon: ICONS.Orange,  title: "Orange" },
      { key: "Red",    icon: ICONS.Red,     title: "Red" },
      { key: "Purple", icon: ICONS.Purple,  title: "Purple" },
      { key: "White",  icon: ICONS.White,   title: "White" },
      { key: "Black",  icon: ICONS.Black,   title: "Black" },
    ];

    /* ----------------------------- state ----------------------------- */
    const N = 5;
    const CENTER = { r: 2, c: 2 };

    const gridEl = document.getElementById("grid");
    const paletteEl = document.getElementById("palette");
    const clearBtn = document.getElementById("clearBtn");

    let currentInk = "None";
    let board = Array.from({ length: N }, () => Array.from({ length: N }, () => null));

    function isCenter(r, c) {
      return r === CENTER.r && c === CENTER.c;
    }

    function hasAnyRed() {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (board[r][c] === "Red") return true;
        }
      }
      return false;
    }

    // If a Red is placed, empty cells should be locked (not clickable).
    // Marked cells are still clickable so you can fix/clear mistakes.
    function canInteractCell(r, c) {
      if (isCenter(r, c)) return false;

      const redPlaced = hasAnyRed();
      const state = board[r][c];

      if (redPlaced && state === null) return false;
      return true;
    }

    function iconEl(src, alt) {
      const img = document.createElement("img");
      img.className = "icon";
      img.src = src;
      img.alt = alt;
      return img;
    }

    function probEl(text) {
      const d = document.createElement("div");
      d.className = "prob";
      d.textContent = text;
      return d;
    }

    /* ----------------------------- rules ----------------------------- */
    function isValidRed(rr, rc) {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const mark = board[r][c];
          if (!mark) continue;

          const dr = Math.abs(r - rr);
          const dc = Math.abs(c - rc);
          const isLine = (r === rr || c === rc);
          const isDiag = (dr === dc);

          if (mark === "Teal"   && !(isLine || isDiag)) return false;
          if (mark === "Blue"   && (isLine || isDiag))  return false;
          if (mark === "Yellow" && !isDiag)             return false;
          if (mark === "Green"  && !isLine)             return false;
          if (mark === "Orange" && !(dr <= 1 && dc <= 1)) return false;

          // Purple/White/Black/Red: no constraints here (they're just marks).
        }
      }
      return true;
    }

    /* ----------------------------- UI build ----------------------------- */
    function createPalette() {
      paletteEl.innerHTML = "";

      INKS.forEach((ink, idx) => {
        const btn = document.createElement("div");
        btn.className = "inkBtn" + (idx === 0 ? " active" : "");
        btn.title = ink.title;

        btn.addEventListener("click", () => {
          currentInk = ink.key;
          document.querySelectorAll(".inkBtn").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
        });

        const img = document.createElement("img");
        img.src = ink.icon;
        img.alt = ink.key;
        btn.appendChild(img);

        paletteEl.appendChild(btn);
      });
    }

    function createGrid() {
      gridEl.innerHTML = "";
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const cell = document.createElement("div");
          cell.className = "cellBox";
          cell.id = `cell-${r}-${c}`;
          cell.addEventListener("click", () => onCellClick(r, c));
          gridEl.appendChild(cell);
        }
      }
      updateLogic();
    }

    /* ----------------------------- interactions ----------------------------- */
    function onCellClick(r, c) {
      if (!canInteractCell(r, c)) return;

      // extra safety: center locked
      if (isCenter(r, c)) return;

      // Optional: prevent placing a *second* red on a different square.
      // (You can still move it by clearing the existing red first.)
      if (currentInk === "Red" && hasAnyRed() && board[r][c] !== "Red") return;

      board[r][c] = (currentInk === "None") ? null : currentInk;
      updateLogic();
    }

    function resetGrid() {
      board = Array.from({ length: N }, () => Array.from({ length: N }, () => null));
      updateLogic();
    }

    clearBtn.addEventListener("click", resetGrid);

    /* ----------------------------- logic + render ----------------------------- */
    function updateLogic() {
      const redPlaced = hasAnyRed();
      const possibleSpots = [];

      if (!redPlaced) {
        for (let r = 0; r < N; r++) {
          for (let c = 0; c < N; c++) {
            if (isCenter(r, c)) continue;
            if (board[r][c] !== null) continue;
            if (isValidRed(r, c)) possibleSpots.push([r, c]);
          }
        }
      }

      const probText =
        (!redPlaced && possibleSpots.length)
          ? (100 / possibleSpots.length).toFixed(0) + "%"
          : "0%";

      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const cell = document.getElementById(`cell-${r}-${c}`);
          const state = board[r][c];

          cell.className = "cellBox";
          cell.innerHTML = "";

          // Center: always mystery + 0%, always locked
          if (isCenter(r, c)) {
            cell.classList.add("blocked", "locked");
            cell.appendChild(iconEl(ICONS.Mystery, "Mystery"));
            cell.appendChild(probEl("0%"));
            continue;
          }

          // If a mark exists: show its icon (no meaning implied)
          if (state) {
            cell.appendChild(iconEl(ICONS[state] || ICONS.Mystery, state));
            if (redPlaced) cell.classList.add("locked"); // only affects cursor; click logic gates it anyway
            // Optional: show 100% under the placed Red to match “rest become 0%”
            if (state === "Red") cell.appendChild(probEl("100%"));
            continue;
          }

          // Empty cells
          if (redPlaced) {
            // With Red placed: everything else is 0% and locked, and shouldn't be clickable
            cell.classList.add("blocked", "locked");
            cell.appendChild(probEl("0%"));
            continue;
          }

          // No red placed yet: show possible vs blocked based on constraints
          const isPossible = possibleSpots.some(p => p[0] === r && p[1] === c);

          if (isPossible) {
            cell.classList.add("possible");
            cell.appendChild(probEl(probText));
          } else {
            cell.classList.add("blocked");
            cell.appendChild(probEl("0%"));
          }
        }
      }
    }

    createPalette();
    createGrid();
  </script>
</body>
</html>
