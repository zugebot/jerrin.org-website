<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Mudae $oq Assistant</title>

    <style>
        :root{
            --bg:#313338;
            --panel:#2b2d31;
            --cell:#4e5058;
            --text:#dbdee1;

            --possible:#5865f2;
            --blocked:#232428;
            --blockedText:#8a8f98;

            --danger:#ed4245;
            --good:#2ecc71;
        }

        body{
            font-family: "gg sans","Helvetica Neue",Helvetica,Arial,sans-serif;
            background: var(--bg);
            color: var(--text);
            margin:0;
            padding:20px;
            display:flex;
            flex-direction:column;
            align-items:center;
            gap: 10px;
        }

        h2{ margin:6px 0 0 0; line-height:1.1; }
        .subtitle{
            margin:0 0 6px 0;
            font-size:0.78rem;
            opacity:0.8;
            text-align:center;
            max-width: 620px;
        }

        .hud{
            width: min(720px, 95vw);
            display:flex;
            flex-wrap:wrap;
            gap:10px;
            justify-content:center;
            align-items:center;
            background: var(--panel);
            border-radius: 10px;
            padding: 10px 12px;
        }

        .hudItem{
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(0,0,0,0.18);
            border-radius: 10px;
            padding: 8px 10px;
            display:flex;
            align-items:center;
            gap: 8px;
            min-width: 160px;
            justify-content:center;
        }

        .hudLabel{ opacity:0.8; font-size:0.82rem; }
        .hudValue{ font-weight:900; font-size:0.95rem; }

        .hudBtn{
            border:none;
            border-radius:10px;
            padding:8px 10px;
            cursor:pointer;
            font-weight:900;
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }
        .hudBtn:hover{ opacity:0.9; }
        .hudBtn.danger{ background: var(--danger); color:#fff; }
        .hudBtn.good{ background: var(--good); color:#fff; }

        .grid{
            display:grid;
            grid-template-columns: repeat(5, 60px);
            gap:8px;
            background: var(--panel);
            padding:15px;
            border-radius:10px;
        }

        .cellBox{
            width:60px;
            height:52px;
            background: var(--cell);
            border-radius:8px;
            border:1px solid rgba(0,0,0,0.12);
            display:flex;
            flex-direction:column;
            justify-content:center;
            align-items:center;
            cursor:pointer;
            user-select:none;
            overflow:hidden;
        }
        .cellBox:hover{ opacity:0.86; }

        .cellBox.possible{ background: var(--possible); color:#fff; }
        .cellBox.blocked{ background: var(--blocked); color: var(--blockedText); }
        .cellBox.locked{ cursor:not-allowed; }

        .icon{
            width:22px;
            height:22px;
            pointer-events:none;
        }

        .prob{
            margin-top:2px;
            font-size:0.78rem;
            font-weight:900;
            line-height:1;
            pointer-events:none;
        }

        .palette{
            display:grid;
            grid-template-columns: repeat(4, 56px);
            gap:10px;
            background: var(--panel);
            padding:14px;
            border-radius:10px;
            justify-content:center;
            align-items:center;
            width: fit-content;
        }

        .inkBtn{
            width:56px;
            height:44px;
            border-radius:10px;
            cursor:pointer;
            border:2px solid transparent;
            background: rgba(255,255,255,0.06);
            display:flex;
            align-items:center;
            justify-content:center;
        }
        .inkBtn:hover{ opacity:0.9; }
        .inkBtn.active{
            border-color:#fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.25);
        }
        .inkBtn img{
            width:26px;
            height:26px;
            pointer-events:none;
        }

        .details{
            width: min(720px, 95vw);
            background: var(--panel);
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 0.85rem;
            opacity: 0.9;
            line-height: 1.35;
        }
        .details code{ opacity: 0.95; }
    </style>
</head>

<body>
<h2>Mudae '$oq' Assistant</h2>
<p class="subtitle">
    You get <b>7 clicks</b> in <b>2:00</b>. Mark results: <b>Purple</b> = found a purple sphere.
    Otherwise mark the clue color for <b># of neighboring purples</b> (8 surrounding tiles):
    Blue=0, Teal=1, Green=2, Yellow=3, Orange=4.
</p>

<div class="hud" id="hud">
    <div class="hudItem">
        <span class="hudLabel">Clicks used</span>
        <span class="hudValue" id="clicksUsed">0</span>
        <span class="hudLabel">/ 7</span>
    </div>

    <div class="hudItem">
        <span class="hudLabel">Purples found</span>
        <span class="hudValue" id="purplesFound">0</span>
        <span class="hudLabel">/ 3</span>
    </div>

    <div class="hudItem">
        <span class="hudLabel">Time</span>
        <span class="hudValue" id="timer">2:00</span>
    </div>

    <button class="hudBtn good" id="startTimerBtn">Start</button>
    <button class="hudBtn" id="pauseTimerBtn">Pause</button>
    <button class="hudBtn danger" id="resetBtn">Clear</button>
    <button class="hudBtn" id="toggleEnforceBtn" title="If ON, you can't mark new cells after 7 clicks.">Enforce: ON</button>
</div>

<div class="grid" id="grid"></div>

<div class="palette" id="palette"></div>

<div class="details" id="details">
    <div><b>Solver:</b> assumes exactly <b>4</b> total purple spheres are hidden on the 5×5 board.</div>
    <div><b>% shown</b> on unclicked tiles is <b>P(tile is purple | your marks)</b>.</div>
    <div>If you’ve already found <b>3 purples</b>, the remaining purple is shown with a <b>Red</b> icon (target).</div>
    <div><b>Tip:</b> paint what you actually see. Purple means you clicked a purple; clue colors mean the tile was <i>not</i> purple.</div>
</div>

<script>
    /* ----------------------------- icons ----------------------------- */
    const ICONS = {
        Purple:  "https://cdn.discordapp.com/emojis/1437140625844867244.webp",
        Blue:    "https://cdn.discordapp.com/emojis/1437140639987929108.webp", // 0
        Teal:    "https://cdn.discordapp.com/emojis/1437140651614535680.webp", // 1
        Green:   "https://cdn.discordapp.com/emojis/1437140664193126441.webp", // 2
        Yellow:  "https://cdn.discordapp.com/emojis/1437140677187338310.webp", // 3
        Orange:  "https://cdn.discordapp.com/emojis/1437140688608432185.webp", // 4
        Red:     "https://cdn.discordapp.com/emojis/1437140700604137554.webp",
        Mystery: "https://cdn.discordapp.com/emojis/1437140748423270441.webp",
    };

    // Palette: Mystery = eraser/unknown
    const INKS = [
        { key: "None",   icon: ICONS.Mystery, title: "Mystery (erase / unknown)" },
        { key: "Purple", icon: ICONS.Purple,  title: "Purple (you found a purple sphere)" },

        { key: "Blue",   icon: ICONS.Blue,    title: "Blue (0 neighboring purples)" },
        { key: "Teal",   icon: ICONS.Teal,    title: "Teal (1 neighboring purple)" },
        { key: "Green",  icon: ICONS.Green,   title: "Green (2 neighboring purples)" },
        { key: "Yellow", icon: ICONS.Yellow,  title: "Yellow (3 neighboring purples)" },
        { key: "Orange", icon: ICONS.Orange,  title: "Orange (4 neighboring purples)" },
    ];

    const CLUE_VALUE = {
        Blue: 0, Teal: 1, Green: 2, Yellow: 3, Orange: 4,
    };

    /* ----------------------------- config/state ----------------------------- */
    const N = 5;
    const TOTAL_PURPLES = 4;
    const MAX_CLICKS = 7;
    const TOTAL_TIME_SEC = 120;

    const gridEl = document.getElementById("grid");
    const paletteEl = document.getElementById("palette");

    const clicksUsedEl = document.getElementById("clicksUsed");
    const purplesFoundEl = document.getElementById("purplesFound");
    const timerEl = document.getElementById("timer");

    const startTimerBtn = document.getElementById("startTimerBtn");
    const pauseTimerBtn = document.getElementById("pauseTimerBtn");
    const resetBtn = document.getElementById("resetBtn");
    const toggleEnforceBtn = document.getElementById("toggleEnforceBtn");

    let currentInk = "None";
    let enforceClicks = true;

    // board[r][c] is one of: null, "Purple", "Blue", "Teal", "Green", "Yellow", "Orange"
    let board = Array.from({ length: N }, () => Array.from({ length: N }, () => null));

    /* ----------------------------- timer ----------------------------- */
    let timeLeft = TOTAL_TIME_SEC;
    let timerRunning = false;
    let timerHandle = null;

    function fmtTime(sec){
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return `${m}:${String(s).padStart(2,'0')}`;
    }

    function setTimerUI(){
        timerEl.textContent = fmtTime(timeLeft);
    }

    function startTimer(){
        if (timerRunning) return;
        timerRunning = true;
        timerHandle = setInterval(() => {
            timeLeft = Math.max(0, timeLeft - 1);
            setTimerUI();
            if (timeLeft === 0) pauseTimer();
        }, 1000);
    }

    function pauseTimer(){
        timerRunning = false;
        if (timerHandle) clearInterval(timerHandle);
        timerHandle = null;
    }

    function resetTimer(){
        pauseTimer();
        timeLeft = TOTAL_TIME_SEC;
        setTimerUI();
    }

    startTimerBtn.addEventListener("click", startTimer);
    pauseTimerBtn.addEventListener("click", pauseTimer);

    /* ----------------------------- neighbors precompute ----------------------------- */
    // Map cell index -> bitmask of its 8 neighbors
    // index = r*N + c (0..24) fits in 32-bit integer
    const neighborMask = Array(N*N).fill(0);

    function idx(r,c){ return r*N + c; }

    for (let r=0; r<N; r++){
        for (let c=0; c<N; c++){
            let mask = 0;
            for (let dr=-1; dr<=1; dr++){
                for (let dc=-1; dc<=1; dc++){
                    if (dr===0 && dc===0) continue;
                    const rr = r + dr;
                    const cc = c + dc;
                    if (rr<0 || rr>=N || cc<0 || cc>=N) continue;
                    mask |= (1 << idx(rr,cc));
                }
            }
            neighborMask[idx(r,c)] = mask;
        }
    }

    function popcount(x){
        // 32-bit popcount
        x = x - ((x >>> 1) & 0x55555555);
        x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
        return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
    }

    /* ----------------------------- UI elements ----------------------------- */
    function iconEl(src, alt){
        const img = document.createElement("img");
        img.className = "icon";
        img.src = src;
        img.alt = alt;
        return img;
    }

    function probEl(text){
        const d = document.createElement("div");
        d.className = "prob";
        d.textContent = text;
        return d;
    }

    /* ----------------------------- palette ----------------------------- */
    function createPalette(){
        paletteEl.innerHTML = "";
        INKS.forEach((ink, i) => {
            const btn = document.createElement("div");
            btn.className = "inkBtn" + (i===0 ? " active" : "");
            btn.title = ink.title;

            btn.addEventListener("click", () => {
                currentInk = ink.key;
                document.querySelectorAll(".inkBtn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
            });

            const img = document.createElement("img");
            img.src = ink.icon;
            img.alt = ink.key;
            btn.appendChild(img);

            paletteEl.appendChild(btn);
        });
    }

    /* ----------------------------- grid ----------------------------- */
    function createGrid(){
        gridEl.innerHTML = "";
        for (let r=0; r<N; r++){
            for (let c=0; c<N; c++){
                const cell = document.createElement("div");
                cell.className = "cellBox";
                cell.id = `cell-${r}-${c}`;
                cell.addEventListener("click", () => onCellClick(r,c));
                gridEl.appendChild(cell);
            }
        }
        updateAll();
    }

    function clicksUsed(){
        let n = 0;
        for (let r=0; r<N; r++){
            for (let c=0; c<N; c++){
                if (board[r][c] !== null) n++;
            }
        }
        return n;
    }

    function purplesFound(){
        let n = 0;
        for (let r=0; r<N; r++){
            for (let c=0; c<N; c++){
                if (board[r][c] === "Purple") n++;
            }
        }
        return n;
    }

    function onCellClick(r,c){
        const used = clicksUsed();
        const state = board[r][c];

        // If enforcing and already used all clicks, only allow edits on already-clicked cells.
        if (enforceClicks && used >= MAX_CLICKS && state === null) return;

        // Apply ink
        board[r][c] = (currentInk === "None") ? null : currentInk;
        updateAll();
    }

    /* ----------------------------- constraints & solving ----------------------------- */
    function buildConstraints(){
        const mustPurple = 0; // we’ll collect in a mask below
        let mustMask = 0;
        let forbidMask = 0;

        // For each clue cell: store {cellIdx, requiredCount}
        const clueList = [];

        for (let r=0; r<N; r++){
            for (let c=0; c<N; c++){
                const s = board[r][c];
                const id = idx(r,c);
                if (s === null) continue;

                if (s === "Purple"){
                    mustMask |= (1 << id);
                } else {
                    // clue cells are known NOT purple
                    forbidMask |= (1 << id);

                    const req = CLUE_VALUE[s];
                    if (req === undefined) continue;
                    clueList.push({ id, req });
                }
            }
        }

        return { mustMask, forbidMask, clueList };
    }

    function enumerateSolutions(){
        const { mustMask, forbidMask, clueList } = buildConstraints();
        const found = popcount(mustMask);

        // impossible right away
        if (found > TOTAL_PURPLES) return { total: 0, purpleCounts: Array(N*N).fill(0) };

        // Candidate cells that are allowed to be purple (not forbidden)
        const candidates = [];
        for (let i=0; i<N*N; i++){
            const bit = (1<<i);
            if (forbidMask & bit) continue;
            candidates.push(i);
        }

        // We need to choose TOTAL_PURPLES cells; mustMask must be subset
        // We'll brute force combinations of 4 across 25 (fast enough).
        let total = 0;
        const purpleCounts = Array(N*N).fill(0);

        // Small pruning: if mustMask has bits not in candidates, impossible
        if ((mustMask & forbidMask) !== 0) return { total: 0, purpleCounts };

        // Another pruning: remaining candidates count
        if (candidates.length < TOTAL_PURPLES) return { total: 0, purpleCounts };

        // Precompute: for each clue, store neighbor mask (int) and required
        const clueData = clueList.map(({id, req}) => ({
            neighbor: neighborMask[id],
            req
        }));

        // Enumerate combinations of 4 indices (i<j<k<l) from 0..(N*N-1)
        // and test constraints.
        // Since TOTAL_PURPLES=4 fixed, this is tight and fast.

        for (let a=0; a<(N*N-3); a++){
            for (let b=a+1; b<(N*N-2); b++){
                for (let c=b+1; c<(N*N-1); c++){
                    for (let d=c+1; d<(N*N); d++){
                        let mask = (1<<a) | (1<<b) | (1<<c) | (1<<d);

                        // must be superset of mustMask
                        if ((mask & mustMask) !== mustMask) continue;

                        // cannot include forbidden
                        if ((mask & forbidMask) !== 0) continue;

                        // Validate all clue constraints
                        let ok = true;
                        for (let t=0; t<clueData.length; t++){
                            const got = popcount(mask & clueData[t].neighbor);
                            if (got !== clueData[t].req){ ok = false; break; }
                        }
                        if (!ok) continue;

                        total++;
                        purpleCounts[a]++; purpleCounts[b]++; purpleCounts[c]++; purpleCounts[d]++;
                    }
                }
            }
        }

        return { total, purpleCounts };
    }

    /* ----------------------------- render ----------------------------- */
    function updateHUD(solTotal){
        clicksUsedEl.textContent = String(clicksUsed());
        purplesFoundEl.textContent = String(Math.min(purplesFound(), 3));

        // Also reflect enforce state
        toggleEnforceBtn.textContent = `Enforce: ${enforceClicks ? "ON" : "OFF"}`;
        toggleEnforceBtn.classList.toggle("good", enforceClicks);
    }

    function updateGrid(){
        const foundPurples = purplesFound();
        const targetMode = foundPurples >= 3; // show remaining as Red target

        const { total, purpleCounts } = enumerateSolutions();

        // If no solutions, show everything as blocked 0% unless already marked
        for (let r=0; r<N; r++){
            for (let c=0; c<N; c++){
                const cell = document.getElementById(`cell-${r}-${c}`);
                const s = board[r][c];
                const id = idx(r,c);

                cell.className = "cellBox";
                cell.innerHTML = "";

                // Marked cells: show their icon (Purple or clue color)
                if (s !== null){
                    const iconKey = (s === "None") ? "Mystery" : s;
                    cell.appendChild(iconEl(ICONS[iconKey] || ICONS.Mystery, iconKey));
                    continue;
                }

                // Unclicked cells: show probability
                const p = (total > 0) ? (purpleCounts[id] / total) : 0;
                const pct = Math.round(p * 100);

                if (pct > 0){
                    cell.classList.add("possible");
                } else {
                    cell.classList.add("blocked");
                }

                // If we already found 3 purples, show red target icon for remaining
                if (targetMode){
                    cell.appendChild(iconEl(ICONS.Red, "Target"));
                } else {
                    cell.appendChild(iconEl(ICONS.Purple, "Purple?"));
                }

                cell.appendChild(probEl(`${pct}%`));

                // click locking when enforcing
                const used = clicksUsed();
                if (enforceClicks && used >= MAX_CLICKS) cell.classList.add("locked");
            }
        }

        updateHUD(total);
    }

    function updateAll(){
        updateGrid();
    }

    /* ----------------------------- controls ----------------------------- */
    function resetAll(){
        board = Array.from({ length: N }, () => Array.from({ length: N }, () => null));
        resetTimer();
        updateAll();
    }

    resetBtn.addEventListener("click", resetAll);

    toggleEnforceBtn.addEventListener("click", () => {
        enforceClicks = !enforceClicks;
        updateAll();
    });

    /* ----------------------------- init ----------------------------- */
    setTimerUI();
    createPalette();
    createGrid();
</script>
</body>
</html>
